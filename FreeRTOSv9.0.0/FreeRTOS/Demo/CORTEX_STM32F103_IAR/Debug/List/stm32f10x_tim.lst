###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        03/May/2017  13:42:12
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\src\stm32f10x_tim.c
#    Command line =  
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\src\stm32f10x_tim.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List\
#        --diag_suppress Pa082,pe191 -o
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Full.h"
#        -I
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\.\
#        -I
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\inc\
#        -I
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\..\Source\include\
#        -I
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\common\include\
#        -Ol --use_c++_inline --require_prototypes
#    List file    =  
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List\stm32f10x_tim.lst
#    Object file  =  
#        E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj\stm32f10x_tim.o
#
###############################################################################

E:\BaiduNetdiskDownload\OneNET开发板--资料、软件下载\资料\RTOS资料\FreeRTOS\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\src\stm32f10x_tim.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_tim.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the TIM firmware functions.
      6          ********************************************************************************
      7          * History:
      8          * 04/02/2007: V0.2
      9          * 02/05/2007: V0.1
     10          * 09/29/2006: V0.01
     11          ********************************************************************************
     12          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     14          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     15          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     16          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     17          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18          *******************************************************************************/
     19          
     20          /* Includes ------------------------------------------------------------------*/
     21          #include "stm32f10x_tim.h"
     22          #include "stm32f10x_rcc.h"
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* ---------------------- TIM registers bit mask ------------------------ */
     27          #define CR1_CEN_Set                 ((u16)0x0001)
     28          #define CR1_CEN_Reset               ((u16)0x03FE)
     29          #define CR1_UDIS_Set                ((u16)0x0002)
     30          #define CR1_UDIS_Reset              ((u16)0x03FD)
     31          #define CR1_URS_Set                 ((u16)0x0004)
     32          #define CR1_URS_Reset               ((u16)0x03FB)
     33          #define CR1_OPM_Mask                ((u16)0x03F7)
     34          #define CR1_CounterMode_Mask        ((u16)0x039F)
     35          #define CR1_ARPE_Set                ((u16)0x0080)
     36          #define CR1_ARPE_Reset              ((u16)0x037F)
     37          #define CR1_CKD_Mask                ((u16)0x00FF)
     38          
     39          #define CR2_CCDS_Set                ((u16)0x0008)
     40          #define CR2_CCDS_Reset              ((u16)0x0007)
     41          #define CR2_MMS_Mask                ((u16)0x0080)
     42          #define CR2_TI1S_Set                ((u16)0x0080)
     43          #define CR2_TI1S_Reset              ((u16)0xFF70)
     44          
     45          #define SMCR_SMS_Mask               ((u16)0xFFF0)
     46          #define SMCR_ETR_Mask               ((u16)0x00F7)
     47          #define SMCR_TS_Mask                ((u16)0xFF87)
     48          #define SMCR_MSM_Mask               ((u16)0xFF77)
     49          #define SMCR_ECE_Set                ((u16)0x4000)
     50          
     51          #define CCMR_CC13S_Mask             ((u16)0x7F7C)
     52          #define CCMR_CC24S_Mask             ((u16)0x7C7F)
     53          #define CCMR_TI13Direct_Set         ((u16)0x0001)
     54          #define CCMR_TI24Direct_Set         ((u16)0x0100)
     55          #define CCMR_OC13FE_Mask            ((u16)0x7F7B)
     56          #define CCMR_OC24FE_Mask            ((u16)0x7B7F)
     57          #define CCMR_OC13PE_Mask            ((u16)0x7F77)
     58          #define CCMR_OC24PE_Mask            ((u16)0x777F)
     59          #define CCMR_OCM13_Mask             ((u16)0x7F0F)
     60          #define CCMR_OCM24_Mask             ((u16)0x0F7F)
     61          #define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
     62          #define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
     63          #define CCMR_IC13F_Mask             ((u16)0xFF0F)
     64          #define CCMR_IC24F_Mask             ((u16)0x0FFF)
     65          #define CCER_CC1P_Mask              ((u16)0xFFFD)
     66          
     67          #define CCER_CC2P_Mask              ((u16)0xFFDF)
     68          #define CCER_CC3P_Mask              ((u16)0xFDFF)
     69          #define CCER_CC4P_Mask              ((u16)0xDFFF)
     70          
     71          #define CCRE_CC1E_Set               ((u16)0x0001)
     72          #define CCRE_CC1E_Reset             ((u16)0xFFFE)
     73          #define CCRE_CC1E_Mask              ((u16)0xFFFE)
     74          
     75          #define CCRE_CC2E_Set               ((u16)0x0010)
     76          #define CCRE_CC2E_Reset             ((u16)0xFFEF)
     77          #define CCRE_CC2E_Mask              ((u16)0xFFEF)
     78          
     79          #define CCRE_CC3E_Set               ((u16)0x0100)
     80          #define CCRE_CC3E_Reset             ((u16)0xFEFF)
     81          
     82          #define CCRE_CC4E_Set               ((u16)0x1000)
     83          #define CCRE_CC4E_Reset             ((u16)0xEFFF)
     84          #define CCRE_CC4E_Mask              ((u16)0xEFFF)
     85          
     86          #define DCR_DMA_Mask                ((u16)0x0000)
     87          
     88          /* TIM private Masks */
     89          #define TIM_Period_Reset_Mask       ((u16)0x0000)
     90          #define TIM_Prescaler_Reset_Mask    ((u16)0x0000)
     91          #define TIM_Pulse_Reset_Mask        ((u16)0x0000)
     92          #define TIM_ICFilter_Mask           ((u8)0x00)
     93          
     94          /* Private macro -------------------------------------------------------------*/
     95          /* Private variables ---------------------------------------------------------*/
     96          static uc16 Tab_OCModeMask[4] = {0xFF00, 0x00FF, 0xFF00, 0x00FF};
     97          static uc16 Tab_PolarityMask[4] = {CCER_CC1P_Mask, CCER_CC2P_Mask, CCER_CC3P_Mask, CCER_CC4P_Mask};
     98          
     99          /* Private function prototypes -----------------------------------------------*/
    100          static void PWMI_Config(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
    101          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    102                                 u8 TIM_ICFilter);
    103          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    104                                 u8 TIM_ICFilter);
    105          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    106                                 u8 TIM_ICFilter);
    107          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    108                                 u8 TIM_ICFilter);
    109          static void ETR_Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
    110                                 u16 TIM_ExtTRGPolarity, u8 ExtTRGFilter);
    111          /* Private functions ---------------------------------------------------------*/
    112          
    113          /*******************************************************************************
    114          * Function Name  : TIM_DeInit
    115          * Description    : Deinitializes the TIMx peripheral registers to their default
    116          *                  reset values.
    117          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    118          * Output         : None
    119          * Return         : None
    120          *******************************************************************************/
    121          void TIM_DeInit(TIM_TypeDef* TIMx)
    122          {  
    123            switch (*(u32*)&TIMx)
    124            {
    125              case TIM2_BASE:
    126                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    127                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    128                break;
    129           
    130              case TIM3_BASE:
    131                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    132                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    133                break;
    134           
    135              case TIM4_BASE:
    136                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    137                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    138                break;
    139           
    140              default:
    141                break;
    142            }
    143          }
    144          
    145          /*******************************************************************************
    146          * Function Name  : TIM_TimeBaseInit
    147          * Description    : Initializes the TIMx Time Base Unit peripheral according to 
    148          *                  the specified parameters in the TIM_TimeBaseInitStruct.
    149          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    150          *                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    151          *                   structure that contains the configuration information for
    152          *                   the specified TIM peripheral.
    153          * Output         : None
    154          * Return         : None
    155          *******************************************************************************/
    156          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    157          {
    158            /* Check the parameters */
    159            assert(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    160            assert(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    161            
    162            /* Set the Autoreload value */
    163            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    164          
    165            /* Set the Prescaler value */
    166            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    167          
    168            /* Select the Counter Mode and set the clock division */
    169            TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
    170            TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
    171                         TIM_TimeBaseInitStruct->TIM_CounterMode;
    172          }
    173          /*******************************************************************************
    174          * Function Name  : TIM_OCInit
    175          * Description    : Initializes the TIMx peripheral according to the specified
    176          *                  parameters in the TIM_OCInitStruct.
    177          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    178          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    179          *                    that contains the configuration information for the specified
    180          *                    TIM peripheral.
    181          * Output         : None
    182          * Return         : None
    183          *******************************************************************************/
    184          void TIM_OCInit(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    185          {
    186            u32 tmpccmrx = 0, tmpccer = 0;
    187            
    188            /* Check the parameters */
    189            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    190            assert(IS_TIM_CHANNEL(TIM_OCInitStruct->TIM_Channel));
    191            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    192          
    193            tmpccer = TIMx->CCER;
    194          
    195            if ((TIM_OCInitStruct->TIM_Channel == (u16)TIM_Channel_1) ||
    196                (TIM_OCInitStruct->TIM_Channel == (u16)TIM_Channel_2))
    197            {
    198              tmpccmrx = TIMx->CCMR1;
    199              
    200              /* Reset the Output Compare Bits */
    201              tmpccmrx &= Tab_OCModeMask[TIM_OCInitStruct->TIM_Channel];
    202          
    203              /* Set the Output Polarity level */
    204              tmpccer &= Tab_PolarityMask[TIM_OCInitStruct->TIM_Channel];
    205          
    206              if (TIM_OCInitStruct->TIM_Channel == TIM_Channel_1)
    207              {
    208                /* Disable the Channel 1: Reset the CCE Bit */
    209                TIMx->CCER &= CCRE_CC1E_Reset;
    210          
    211                /* Select the Output Compare Mode */
    212                tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    213          
    214                /* Set the Capture Compare Register value */
    215                TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    216          
    217                /* Set the Capture Compare Enable Bit */
    218                tmpccer |= CCRE_CC1E_Set;
    219          
    220                /* Set the Capture Compare Polarity */
    221                tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    222              }
    223              else /* TIM_Channel_2 */
    224              {
    225                /* Disable the Channel 2: Reset the CCE Bit */
    226                TIMx->CCER &= CCRE_CC2E_Reset;
    227          
    228                /* Select the Output Compare Mode */
    229                tmpccmrx |= (u32)TIM_OCInitStruct->TIM_OCMode << 8;
    230          
    231                /* Set the Capture Compare Register value */
    232                TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    233          
    234                /* Set the Capture Compare Enable Bit */
    235                tmpccer |= CCRE_CC2E_Set;
    236          
    237                /* Set the Capture Compare Polarity */
    238                tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 4;
    239              }
    240          
    241              TIMx->CCMR1 = (u16)tmpccmrx;
    242            }
    243            else 
    244            {
    245              if ((TIM_OCInitStruct->TIM_Channel == TIM_Channel_3) ||
    246                  (TIM_OCInitStruct->TIM_Channel == TIM_Channel_4))
    247              { 
    248                tmpccmrx = TIMx->CCMR2;
    249          
    250                /* Reset the Output Compare Bits */
    251                tmpccmrx &= Tab_OCModeMask[TIM_OCInitStruct->TIM_Channel];
    252          
    253                /* Set the Output Polarity level */
    254                tmpccer &= Tab_PolarityMask[TIM_OCInitStruct->TIM_Channel];
    255          
    256                if (TIM_OCInitStruct->TIM_Channel == TIM_Channel_3)
    257                {
    258                  /* Disable the Channel 3: Reset the CCE Bit */
    259                  TIMx->CCER &= CCRE_CC3E_Reset;
    260          
    261                  /* Select the Output Compare Mode */
    262                  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    263          
    264                  /* Set the Capture Compare Register value */
    265                  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    266          
    267                  /* Set the Capture Compare Enable Bit */
    268                  tmpccer |= CCRE_CC3E_Set;
    269          
    270                  /* Set the Capture Compare Polarity */
    271                  tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 8;
    272                }
    273                else  /* TIM_Channel_4 */
    274                {
    275                  /* Disable the Channel 4: Reset the CCE Bit */
    276                  TIMx->CCER &= CCRE_CC4E_Reset;
    277          
    278                 /* Select the Output Compare Mode */
    279                  tmpccmrx |= (u32)TIM_OCInitStruct->TIM_OCMode << 8;
    280          
    281                  /* Set the Capture Compare Register value */
    282                  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    283          
    284                  /* Set the Capture Compare Enable Bit */
    285                  tmpccer |= CCRE_CC4E_Set;
    286          
    287                  /* Set the Capture Compare Polarity */
    288                  tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 12;
    289                }
    290          
    291                TIMx->CCMR2 = (u16)tmpccmrx;
    292              }
    293            }
    294            
    295            TIMx->CCER = (u16)tmpccer;
    296          }
    297          
    298          /*******************************************************************************
    299          * Function Name  : TIM_ICInit
    300          * Description    : Initializes the TIMx peripheral according to the specified
    301          *                  parameters in the TIM_ICInitStruct.
    302          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    303          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    304          *                    that contains the configuration information for the specified
    305          *                    TIM peripheral.
    306          * Output         : None
    307          * Return         : None
    308          *******************************************************************************/
    309          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    310          {
    311            /* Check the parameters */
    312            assert(IS_TIM_IC_MODE(TIM_ICInitStruct->TIM_ICMode));
    313            assert(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    314            assert(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    315            assert(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    316            assert(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    317            assert(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    318            
    319            if (TIM_ICInitStruct->TIM_ICMode == TIM_ICMode_ICAP)
    320            {
    321              if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
    322              {
    323                /* TI1 Configuration */
    324                TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    325                           TIM_ICInitStruct->TIM_ICSelection,
    326                           TIM_ICInitStruct->TIM_ICFilter);
    327          
    328                /* Set the Input Capture Prescaler value */
    329                TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    330              }
    331              else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
    332              {
    333                /* TI2 Configuration */
    334                TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    335                           TIM_ICInitStruct->TIM_ICSelection,
    336                           TIM_ICInitStruct->TIM_ICFilter);
    337          
    338                /* Set the Input Capture Prescaler value */
    339                TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    340              }
    341              else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
    342              {
    343                /* TI3 Configuration */
    344                TI3_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    345                           TIM_ICInitStruct->TIM_ICSelection,
    346                           TIM_ICInitStruct->TIM_ICFilter);
    347          
    348                /* Set the Input Capture Prescaler value */
    349                TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    350              }
    351              else /* TIM_Channel_4 */
    352              {
    353                /* TI4 Configuration */
    354                TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    355                           TIM_ICInitStruct->TIM_ICSelection,
    356                           TIM_ICInitStruct->TIM_ICFilter);
    357          
    358                /* Set the Input Capture Prescaler value */
    359                TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    360              }
    361            }
    362            else
    363            {
    364              PWMI_Config(TIMx, TIM_ICInitStruct);
    365            }
    366          }
    367          
    368          /*******************************************************************************
    369          * Function Name  : TIM_TimeBaseStructInit
    370          * Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
    371          * Input          : - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    372          *                    structure which will be initialized.
    373          * Output         : None
    374          * Return         : None
    375          *******************************************************************************/
    376          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    377          {
    378            /* Set the default configuration */
    379            TIM_TimeBaseInitStruct->TIM_Period = TIM_Period_Reset_Mask;
    380            TIM_TimeBaseInitStruct->TIM_Prescaler = TIM_Prescaler_Reset_Mask;
    381            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    382            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    383          }
    384          
    385          /*******************************************************************************
    386          * Function Name  : TIM_OCStructInit
    387          * Description    : Fills each TIM_OCInitStruct member with its default value.
    388          * Input          : - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    389          *                    which will be initialized.
    390          * Output         : None
    391          * Return         : None
    392          *******************************************************************************/
    393          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    394          {
    395            /* Set the default configuration */
    396            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    397            TIM_OCInitStruct->TIM_Channel = TIM_Channel_1;
    398            TIM_OCInitStruct->TIM_Pulse = TIM_Pulse_Reset_Mask;
    399            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    400          }
    401          
    402          /*******************************************************************************
    403          * Function Name  : TIM_ICStructInit
    404          * Description    : Fills each TIM_InitStruct member with its default value.
    405          * Input          : - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    406          *                    which will be initialized.
    407          * Output         : None
    408          * Return         : None
    409          *******************************************************************************/
    410          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    411          {
    412            /* Set the default configuration */
    413            TIM_ICInitStruct->TIM_ICMode = TIM_ICMode_ICAP;
    414            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
    415            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
    416            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
    417            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
    418            TIM_ICInitStruct->TIM_ICFilter = TIM_ICFilter_Mask;
    419          }
    420          
    421          /*******************************************************************************
    422          * Function Name  : TIM_Cmd
    423          * Description    : Enables or disables the specified TIM peripheral.
    424          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIMx peripheral.
    425          *                  - Newstate: new state of the TIMx peripheral.
    426          *                    This parameter can be: ENABLE or DISABLE.
    427          * Output         : None
    428          * Return         : None
    429          *******************************************************************************/
    430          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    431          {
    432            /* Check the parameters */
    433            assert(IS_FUNCTIONAL_STATE(NewState));
    434            
    435            if (NewState != DISABLE)
    436            {
    437              /* Enable the TIM Counter */
    438              TIMx->CR1 |= CR1_CEN_Set;
    439            }
    440            else
    441            {
    442              /* Disable the TIM Counter */
    443              TIMx->CR1 &= CR1_CEN_Reset;
    444            }
    445          }
    446          
    447          /*******************************************************************************
    448          * Function Name  : TIM_ITConfig
    449          * Description    : Enables or disables the TIMx interrupts.
    450          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    451          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    452          *                    or disabled.
    453          *                    This parameter can be any combination of the following values:
    454          *                       - TIM_IT_Update: Timer update Interrupt
    455          *                       - TIM_IT_CC1: Capture Compare 1 Interrupt
    456          *                       - TIM_IT_CC2: Capture Compare 2 Interrupt
    457          *                       - TIM_IT_CC3: Capture Compare 3 Interrupt
    458          *                       - TIM_IT_CC4: Capture Compare 4 Interrupt
    459          *                       - TIM_IT_Trigger: Trigger Interrupt
    460          *                  - Newstate: new state of the specified TIMx interrupts.
    461          *                    This parameter can be: ENABLE or DISABLE.
    462          * Output         : None
    463          * Return         : None
    464          *******************************************************************************/
    465          void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
    466          {
    467            /* Check the parameters */
    468            assert(IS_TIM_IT(TIM_IT));
    469            assert(IS_FUNCTIONAL_STATE(NewState));
    470            
    471            if (NewState != DISABLE)
    472            {
    473              /* Enable the Interrupt sources */
    474              TIMx->DIER |= TIM_IT;
    475            }
    476            else
    477            {
    478              /* Disable the Interrupt sources */
    479              TIMx->DIER &= (u16)(~TIM_IT);
    480            }
    481          }
    482          
    483          /*******************************************************************************
    484          * Function Name  : TIM_DMAConfig
    485          * Description    : Configures the TIMxs DMA interface.
    486          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    487          *                  - TIM_DMABase: DMA Base address.
    488          *                    This parameter can be one of the following values:
    489          *                       - TIM_DMABase_CR1, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    490          *                         TIM_DMABase_DIER, TIM_DMABase_SR, TIM_DMABase_EGR,
    491          *                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    492          *                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    493          *                         TIM_DMABase_CCR1, TIM_DMABase_CCR2, TIM_DMABase_CCR3,
    494          *                         TIM_DMABase_CCR4, TIM_DMABase_DCR.
    495          *                  - TIM_DMABurstLength: DMA Burst length.
    496          *                    This parameter can be one value between:
    497          *                    TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    498          * Output         : None
    499          * Return         : None
    500          *******************************************************************************/
    501          void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
    502          {
    503            u32 tmpdcr = 0;
    504          
    505            /* Check the parameters */
    506            assert(IS_TIM_DMA_BASE(TIM_DMABase));
    507            assert(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    508            
    509            tmpdcr = TIMx->DCR;
    510          
    511            /* Reset the DBA and the DBL Bits */
    512            tmpdcr &= DCR_DMA_Mask;
    513          
    514            /* Set the DMA Base and the DMA Burst Length */
    515            tmpdcr |= TIM_DMABase | TIM_DMABurstLength;
    516          
    517            TIMx->DCR = (u16)tmpdcr;
    518          }
    519          
    520          /*******************************************************************************
    521          * Function Name  : TIM_DMACmd
    522          * Description    : Enables or disables the TIMxs DMA Requests.
    523          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    524          *                  - TIM_DMASources: specifies the DMA Request sources.
    525          *                    This parameter can be any combination of the following values:
    526          *                       - TIM_DMA_CC1: Capture Compare 1 DMA source
    527          *                       - TIM_DMA_CC2: Capture Compare 2 DMA source
    528          *                       - TIM_DMA_CC3: Capture Compare 3 DMA source
    529          *                       - TIM_DMA_CC4: Capture Compare 4 DMA source
    530          *                       - TIM_DMA_Trigger: Trigger DMA source
    531          *                  - Newstate: new state of the DMA Request sources.
    532          *                    This parameter can be: ENABLE or DISABLE.
    533          * Output         : None
    534          * Return         : None
    535          *******************************************************************************/
    536          void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState Newstate)
    537          {
    538            u32 tmpdier = 0;
    539            
    540            /* Check the parameters */
    541            assert(IS_TIM_DMA_SOURCE(TIM_DMASource));
    542            assert(IS_FUNCTIONAL_STATE(Newstate));
    543          
    544            tmpdier = TIMx->DIER;
    545          
    546            if (Newstate != DISABLE)
    547            {
    548              /* Enable the DMA sources */
    549              tmpdier |= TIM_DMASource;
    550            }
    551            else
    552            {
    553              /* Disable the DMA sources */
    554              tmpdier &= (u16)(~TIM_DMASource);
    555            }
    556            TIMx->DIER = (u16)tmpdier;
    557          }
    558          
    559          /*******************************************************************************
    560          * Function Name  : TIM_InternalClockConfig
    561          * Description    : Configures the TIMx interrnal Clock
    562          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    563          * Output         : None
    564          * Return         : None
    565          *******************************************************************************/
    566          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
    567          {
    568            /* Disable slave mode to clock the prescaler directly with the internal clock */
    569            TIMx->SMCR &=  SMCR_SMS_Mask;
    570          }
    571          /*******************************************************************************
    572          * Function Name  : TIM_ITRxExternalClockConfig
    573          * Description    : Configures the TIMx Internal Trigger as External Clock
    574          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    575          *                  - TIM_ITRSource: Trigger source.
    576          *                    This parameter can be one of the following values:
    577          *                       - TIM_TS_ITR0: Internal Trigger 0
    578          *                       - TIM_TS_ITR1: Internal Trigger 1
    579          *                       - TIM_TS_ITR2: Internal Trigger 2
    580          *                       - TIM_TS_ITR3: Internal Trigger 3
    581          * Output         : None
    582          * Return         : None
    583          *******************************************************************************/
    584          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
    585          {
    586            /* Check the parameters */
    587            assert(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
    588          
    589            /* Select the Internal Trigger */
    590            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
    591          
    592            /* Select the External clock mode1 */
    593            TIMx->SMCR |= TIM_SlaveMode_External1;
    594          }
    595          /*******************************************************************************
    596          * Function Name  : TIM_TIxExternalClockConfig
    597          * Description    : Configures the TIMx Trigger as External Clock
    598          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    599          *                  - TIM_TIxExternalCLKSource: Trigger source.
    600          *                    This parameter can be one of the following values:
    601          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
    602          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
    603          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
    604          *                  - TIM_ICPolarity: specifies the TIx Polarity.
    605          *                    This parameter can be:
    606          *                       - TIM_ICPolarity_Rising
    607          *                       - TIM_ICPolarity_Falling
    608          *                   - ICFilter : specifies the filter value.
    609          *                     This parameter must be a value between 0x0 and 0xF.
    610          * Output         : None
    611          * Return         : None
    612          *******************************************************************************/
    613          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
    614                                          u16 TIM_ICPolarity, u8 ICFilter)
    615          {
    616            /* Check the parameters */
    617            assert(IS_TIM_TIX_TRIGGER_SELECTION(TIM_TIxExternalCLKSource));
    618            assert(IS_TIM_IC_POLARITY(TIM_ICPolarity));
    619            assert(IS_TIM_IC_FILTER(ICFilter));
    620          
    621            /* Configure the Timer Input Clock Source */
    622            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
    623            {
    624              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    625            }
    626            else
    627            {
    628              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    629            }
    630          
    631            /* Select the Trigger source */
    632            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
    633          
    634            /* Select the External clock mode1 */
    635            TIMx->SMCR |= TIM_SlaveMode_External1;
    636          }
    637          
    638          /*******************************************************************************
    639          * Function Name  : TIM_ETRClockMode1Config
    640          * Description    : Configures the External clock Mode1
    641          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    642          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    643          *                    It can be one of the following values:
    644          *                       - TIM_ExtTRGPSC_OFF
    645          *                       - TIM_ExtTRGPSC_DIV2
    646          *                       - TIM_ExtTRGPSC_DIV4
    647          *                       - TIM_ExtTRGPSC_DIV8.
    648          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    649          *                    It can be one of the following values:
    650          *                       - TIM_ExtTRGPolarity_Inverted
    651          *                       - TIM_ExtTRGPolarity_NonInverted
    652          *                  - ExtTRGFilter: External Trigger Filter.
    653          *                    This parameter must be a value between 0x00 and 0x0F
    654          * Output         : None
    655          * Return         : None
    656          *******************************************************************************/
    657          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
    658                                       u8 ExtTRGFilter)
    659          {
    660            /* Check the parameters */
    661            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    662            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    663          
    664            /* Configure the ETR Clock source */
    665            ETR_Config(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    666          
    667            /* Select the External clock mode1 */
    668            TIMx->SMCR &= SMCR_SMS_Mask;
    669            TIMx->SMCR |= TIM_SlaveMode_External1;
    670          
    671            /* Select the Trigger selection : ETRF */
    672            TIMx->SMCR &= SMCR_TS_Mask;
    673            TIMx->SMCR |= TIM_TS_ETRF;
    674          }
    675          
    676          /*******************************************************************************
    677          * Function Name  : TIM_ETRClockMode2Config
    678          * Description    : Configures the External clock Mode2
    679          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    680          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    681          *                    It can be one of the following values:
    682          *                       - TIM_ExtTRGPSC_OFF
    683          *                       - TIM_ExtTRGPSC_DIV2
    684          *                       - TIM_ExtTRGPSC_DIV4
    685          *                       - TIM_ExtTRGPSC_DIV8
    686          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    687          *                    It can be one of the following values:
    688          *                       - TIM_ExtTRGPolarity_Inverted
    689          *                       - TIM_ExtTRGPolarity_NonInverted
    690          *                  - ExtTRGFilter: External Trigger Filter.
    691          *                    This parameter must be a value between 0x00 and 0x0F
    692          * Output         : None
    693          * Return         : None
    694          *******************************************************************************/
    695          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
    696                                       u16 TIM_ExtTRGPolarity, u8 ExtTRGFilter)
    697          {
    698            /* Check the parameters */
    699            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    700            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    701          
    702            /* Configure the ETR Clock source */
    703            ETR_Config(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    704          
    705            /* Enable the External clock mode2 */
    706            TIMx->SMCR |= SMCR_ECE_Set;
    707          }
    708          /*******************************************************************************
    709          * Function Name  : TIM_SelectInputTrigger
    710          * Description    : Selects the Input Trigger source
    711          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    712          *                  - TIM_InputTriggerSource: The Input Trigger source.
    713          *                    This parameter can be one of the following values:
    714          *                       - TIM_TS_ITR0: Internal Trigger 0
    715          *                       - TIM_TS_ITR1: Internal Trigger 1
    716          *                       - TIM_TS_ITR2: Internal Trigger 2
    717          *                       - TIM_TS_ITR3: Internal Trigger 3
    718          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
    719          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
    720          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
    721          *                       - TIM_TS_ETRF: External Trigger input
    722          * Output         : None
    723          * Return         : None
    724          *******************************************************************************/
    725          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
    726          {
    727            u32 tmpsmcr = 0;
    728          
    729            /* Check the parameters */
    730            assert(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
    731          
    732            tmpsmcr = TIMx->SMCR;
    733          
    734            /* Select the Tgigger Source */
    735            tmpsmcr &= SMCR_TS_Mask;
    736            tmpsmcr |= TIM_InputTriggerSource;
    737          
    738            TIMx->SMCR = (u16)tmpsmcr;
    739          }
    740          
    741          /*******************************************************************************
    742          * Function Name  : TIM_PrescalerConfig
    743          * Description    : Configures the TIMx Prescaler.
    744          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    745          *                  - Prescaler: specifies the Prescaler Register value
    746          *                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    747          *                    This parameter can be one of the following values:
    748          *                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
    749          *                         the update event.
    750          *                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
    751          *                         immediatly.
    752          * Output         : None
    753          * Return         : None
    754          *******************************************************************************/
    755          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
    756          {
    757            /* Check the parameters */
    758            assert(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    759          
    760            /* Set the Prescaler value */
    761            TIMx->PSC = Prescaler;
    762          
    763            /* Set or reset the UG Bit */
    764            if (TIM_PSCReloadMode == TIM_PSCReloadMode_Immediate)
    765            {
    766              TIMx->EGR |= TIM_EventSource_Update;
    767            }
    768            else
    769            {
    770              TIMx->EGR &= TIM_EventSource_Update;
    771            }
    772          }
    773          
    774          /*******************************************************************************
    775          * Function Name  : TIM_CounterModeConfig
    776          * Description    : Specifies the TIMx Counter Mode to be used.
    777          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    778          *                  - TIM_CounterMode: specifies the Counter Mode to be used
    779          *                    This parameter can be one of the following values:
    780          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
    781          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
    782          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    783          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    784          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    785          * Output         : None
    786          * Return         : None
    787          *******************************************************************************/
    788          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
    789          {
    790            u32 tmpcr1 = 0;
    791          
    792            /* Check the parameters */
    793            assert(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    794          
    795            tmpcr1 = TIMx->CR1;
    796          
    797            /* Reset the CMS and DIR Bits */
    798            tmpcr1 &= CR1_CounterMode_Mask;
    799          
    800            /* Set the Counter Mode */
    801            tmpcr1 |= TIM_CounterMode;
    802          
    803            TIMx->CR1 = (u16)tmpcr1;
    804          }
    805          
    806          /*******************************************************************************
    807          * Function Name  : TIM_ForcedOC1Config
    808          * Description    : Forces the TIMx output 1 waveform to active or inactive level.
    809          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    810          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    811          *                    the output waveform.
    812          *                    This parameter can be one of the following values:
    813          *                       - TIM_ForcedAction_Active: Force active level on OC1REF
    814          *                       - TIM_ForcedAction_InActive: Force inactive level on
    815          *                         OC1REF.
    816          * Output         : None
    817          * Return         : None
    818          *******************************************************************************/
    819          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    820          {
    821            u32 tmpccmr1 = 0;
    822          
    823            /* Check the parameters */
    824            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    825          
    826            tmpccmr1 = TIMx->CCMR1;
    827          
    828            /* Reset the OCM Bits */
    829            tmpccmr1 &= CCMR_OCM13_Mask;
    830          
    831            /* Configure The Forced output Mode */
    832            tmpccmr1 |= TIM_ForcedAction;
    833          
    834            TIMx->CCMR1 = (u16)tmpccmr1;
    835          }
    836          
    837          /*******************************************************************************
    838          * Function Name  : TIM_ForcedOC2Config
    839          * Description    : Forces the TIMx output 2 waveform to active or inactive level.
    840          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    841          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    842          *                    the output waveform.
    843          *                    This parameter can be one of the following values:
    844          *                       - TIM_ForcedAction_Active: Force active level on OC2REF
    845          *                       - TIM_ForcedAction_InActive: Force inactive level on
    846          *                         OC2REF.
    847          * Output         : None
    848          * Return         : None
    849          *******************************************************************************/
    850          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    851          {
    852            u32 tmpccmr1 = 0;
    853          
    854            /* Check the parameters */
    855            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    856          
    857            tmpccmr1 = TIMx->CCMR1;
    858          
    859            /* Reset the OCM Bits */
    860            tmpccmr1 &= CCMR_OCM24_Mask;
    861          
    862            /* Configure The Forced output Mode */
    863            tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
    864          
    865            TIMx->CCMR1 = (u16)tmpccmr1;
    866          }
    867          
    868          /*******************************************************************************
    869          * Function Name  : TIM_ForcedOC3Config
    870          * Description    : Forces the TIMx output 3 waveform to active or inactive level.
    871          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    872          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    873          *                    the output waveform.
    874          *                    This parameter can be one of the following values:
    875          *                       - TIM_ForcedAction_Active: Force active level on OC3REF
    876          *                       - TIM_ForcedAction_InActive: Force inactive level on
    877          *                         OC3REF.
    878          * Output         : None
    879          * Return         : None
    880          *******************************************************************************/
    881          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    882          {
    883            u32 tmpccmr2 = 0;
    884          
    885            /* Check the parameters */
    886            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    887          
    888            tmpccmr2 = TIMx->CCMR2;
    889          
    890            /* Reset the OCM Bits */
    891            tmpccmr2 &= CCMR_OCM13_Mask;
    892          
    893            /* Configure The Forced output Mode */
    894            tmpccmr2 |= TIM_ForcedAction;
    895          
    896            TIMx->CCMR2 = (u16)tmpccmr2;
    897          }
    898          
    899          /*******************************************************************************
    900          * Function Name  : TIM_ForcedOC4Config
    901          * Description    : Forces the TIMx output 4 waveform to active or inactive level.
    902          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    903          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    904          *                    the output waveform.
    905          *                    This parameter can be one of the following values:
    906          *                       - TIM_ForcedAction_Active: Force active level on OC4REF
    907          *                       - TIM_ForcedAction_InActive: Force inactive level on
    908          *                         OC4REF.
    909          * Output         : None
    910          * Return         : None
    911          *******************************************************************************/
    912          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    913          {
    914            u32 tmpccmr2 = 0;
    915          
    916            /* Check the parameters */
    917            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    918          
    919            tmpccmr2 = TIMx->CCMR2;
    920          
    921            /* Reset the OCM Bits */
    922            tmpccmr2 &= CCMR_OCM24_Mask;
    923          
    924            /* Configure The Forced output Mode */
    925            tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
    926          
    927            TIMx->CCMR2 = (u16)tmpccmr2;
    928          }
    929          
    930          /*******************************************************************************
    931          * Function Name  : TIM_ARRPreloadConfig
    932          * Description    : Enables or disables TIMx peripheral Preload register on ARR.
    933          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    934          *                  - Newstate: new state of the TIMx peripheral Preload register
    935          *                    This parameter can be: ENABLE or DISABLE.
    936          * Output         : None
    937          * Return         : None
    938          *******************************************************************************/
    939          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState Newstate)
    940          {
    941            u32 tmpcr1 = 0;
    942            
    943            /* Check the parameters */
    944            assert(IS_FUNCTIONAL_STATE(Newstate));
    945          
    946            tmpcr1 = TIMx->CR1;
    947          
    948            if (Newstate != DISABLE)
    949            {
    950              /* Set the ARR Preload Bit */
    951              tmpcr1 |= CR1_ARPE_Set;
    952            }
    953            else
    954            {
    955              /* Reset the ARR Preload Bit */
    956              tmpcr1 &= CR1_ARPE_Reset;
    957            }
    958          
    959            TIMx->CR1 = (u16)tmpcr1;
    960          }
    961          
    962          /*******************************************************************************
    963          * Function Name  : TIM_SelectCCDMA
    964          * Description    : Selects the TIMx peripheral Capture Compare DMA source.
    965          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    966          *                  - Newstate: new state of the Capture Compare DMA source
    967          *                    This parameter can be: ENABLE or DISABLE.
    968          * Output         : None
    969          * Return         : None
    970          *******************************************************************************/
    971          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState Newstate)
    972          {
    973            u32 tmpcr2 = 0;
    974          
    975            /* Check the parameters */
    976            assert(IS_FUNCTIONAL_STATE(Newstate));
    977          
    978            tmpcr2 = TIMx->CR2;
    979          
    980            if (Newstate != DISABLE)
    981            {
    982              /* Set the CCDS Bit */
    983              tmpcr2 |= CR2_CCDS_Set;
    984            }
    985            else
    986            {
    987              /* Reset the CCDS Bit */
    988              tmpcr2 &= CR2_CCDS_Reset;
    989            }
    990          
    991            TIMx->CR2 = (u16)tmpcr2;
    992          }
    993          
    994          /*******************************************************************************
    995          * Function Name  : TIM_OC1PreloadConfig
    996          * Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
    997          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    998          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
    999          *                    register
   1000          *                    This parameter can be one of the following values:
   1001          *                       - TIM_OCPreload_Enable
   1002          *                       - TIM_OCPreload_Disable
   1003          * Output         : None
   1004          * Return         : None
   1005          *******************************************************************************/
   1006          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1007          {
   1008            u32 tmpccmr1 = 0;
   1009          
   1010            /* Check the parameters */
   1011            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1012          
   1013            tmpccmr1 = TIMx->CCMR1;
   1014          
   1015            /* Reset the OCPE Bit */
   1016            tmpccmr1 &= CCMR_OC13PE_Mask;
   1017          
   1018            /* Enable or Disable the Output Compare Preload feature */
   1019            tmpccmr1 |= TIM_OCPreload;
   1020          
   1021            TIMx->CCMR1 = (u16)tmpccmr1;
   1022          }
   1023          
   1024          /*******************************************************************************
   1025          * Function Name  : TIM_OC2PreloadConfig
   1026          * Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
   1027          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1028          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1029          *                    register
   1030          *                    This parameter can be one of the following values:
   1031          *                       - TIM_OCPreload_Enable
   1032          *                       - TIM_OCPreload_Disable
   1033          * Output         : None
   1034          * Return         : None
   1035          *******************************************************************************/
   1036          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1037          {
   1038            u32 tmpccmr1 = 0;
   1039          
   1040            /* Check the parameters */
   1041            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1042          
   1043            tmpccmr1 = TIMx->CCMR1;
   1044          
   1045            /* Reset the OCPE Bit */
   1046            tmpccmr1 &= CCMR_OC24PE_Mask;
   1047          
   1048            /* Enable or Disable the Output Compare Preload feature */
   1049            tmpccmr1 |= (u16)(TIM_OCPreload << 8);
   1050          
   1051            TIMx->CCMR1 = (u16)tmpccmr1;
   1052          }
   1053          
   1054          /*******************************************************************************
   1055          * Function Name  : TIM_OC3PreloadConfig
   1056          * Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
   1057          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1058          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1059          *                    register
   1060          *                    This parameter can be one of the following values:
   1061          *                       - TIM_OCPreload_Enable
   1062          *                       - TIM_OCPreload_Disable
   1063          * Output         : None
   1064          * Return         : None
   1065          *******************************************************************************/
   1066          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1067          {
   1068            u32 tmpccmr2 = 0;
   1069          
   1070            /* Check the parameters */
   1071            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1072          
   1073            tmpccmr2 = TIMx->CCMR2;
   1074          
   1075            /* Reset the OCPE Bit */
   1076            tmpccmr2 &= CCMR_OC13PE_Mask;
   1077          
   1078            /* Enable or Disable the Output Compare Preload feature */
   1079            tmpccmr2 |= TIM_OCPreload;
   1080          
   1081            TIMx->CCMR2 = (u16)tmpccmr2;
   1082          }
   1083          
   1084          /*******************************************************************************
   1085          * Function Name  : TIM_OC4PreloadConfig
   1086          * Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
   1087          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1088          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1089          *                    register
   1090          *                    This parameter can be one of the following values:
   1091          *                       - TIM_OCPreload_Enable
   1092          *                       - TIM_OCPreload_Disable
   1093          * Output         : None
   1094          * Return         : None
   1095          *******************************************************************************/
   1096          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1097          {
   1098            u32 tmpccmr2 = 0;
   1099          
   1100            /* Check the parameters */
   1101            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1102          
   1103            tmpccmr2 = TIMx->CCMR2;
   1104          
   1105            /* Reset the OCPE Bit */
   1106            tmpccmr2 &= CCMR_OC24PE_Mask;
   1107          
   1108            /* Enable or Disable the Output Compare Preload feature */
   1109            tmpccmr2 |= (u16)(TIM_OCPreload << 8);
   1110          
   1111            TIMx->CCMR2 = (u16)tmpccmr2;
   1112          }
   1113          
   1114          /*******************************************************************************
   1115          * Function Name  : TIM_OC1FastConfig
   1116          * Description    : Configures the TIMx Output Compare 1 Fast feature.
   1117          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1118          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1119          *                    This parameter can be one of the following values:
   1120          *                       - TIM_OCFast_Enable
   1121          *                       - TIM_OCFast_Disable
   1122          * Output         : None
   1123          * Return         : None
   1124          *******************************************************************************/
   1125          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1126          {
   1127            u32 tmpccmr1 = 0;
   1128          
   1129            /* Check the parameters */
   1130            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1131          
   1132            tmpccmr1 = TIMx->CCMR1;
   1133          
   1134            /* Reset the OCFE Bit */
   1135            tmpccmr1 &= CCMR_OC13FE_Mask;
   1136          
   1137            /* Enable or Disable the Output Compare Fast Bit */
   1138            tmpccmr1 |= TIM_OCFast;
   1139          
   1140            TIMx->CCMR1 = (u16)tmpccmr1;
   1141          }
   1142          
   1143          /*******************************************************************************
   1144          * Function Name  : TIM_OC2FastConfig
   1145          * Description    : Configures the TIMx Output Compare 2 Fast feature.
   1146          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1147          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1148          *                    This parameter can be one of the following values:
   1149          *                       - TIM_OCFast_Enable
   1150          *                       - TIM_OCFast_Disable
   1151          * Output         : None
   1152          * Return         : None
   1153          *******************************************************************************/
   1154          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1155          {
   1156            u32 tmpccmr1 = 0;
   1157          
   1158            /* Check the parameters */
   1159            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1160          
   1161            tmpccmr1 = TIMx->CCMR1;
   1162          
   1163            /* Reset the OCFE Bit */
   1164            tmpccmr1 &= CCMR_OC24FE_Mask;
   1165          
   1166            /* Enable or Disable the Output Compare Fast Bit */
   1167            tmpccmr1 |= (u16)(TIM_OCFast << 8);
   1168          
   1169            TIMx->CCMR1 = (u16)tmpccmr1;
   1170          }
   1171          
   1172          /*******************************************************************************
   1173          * Function Name  : TIM_OC3FastConfig
   1174          * Description    : Configures the TIMx Output Compare 3 Fast feature.
   1175          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1176          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1177          *                    This parameter can be one of the following values:
   1178          *                       - TIM_OCFast_Enable
   1179          *                       - TIM_OCFast_Disable
   1180          * Output         : None
   1181          * Return         : None
   1182          *******************************************************************************/
   1183          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1184          {
   1185            u32 tmpccmr2 = 0;
   1186          
   1187            /* Check the parameters */
   1188            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1189          
   1190            tmpccmr2 = TIMx->CCMR2;
   1191          
   1192            /* Reset the OCFE Bit */
   1193            tmpccmr2 &= CCMR_OC13FE_Mask;
   1194          
   1195            /* Enable or Disable the Output Compare Fast Bit */
   1196            tmpccmr2 |= TIM_OCFast;
   1197          
   1198            TIMx->CCMR2 = (u16)tmpccmr2;
   1199          }
   1200          
   1201          /*******************************************************************************
   1202          * Function Name  : TIM_OC4FastConfig
   1203          * Description    : Configures the TIMx Output Compare 4 Fast feature.
   1204          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1205          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1206          *                    This parameter can be one of the following values:
   1207          *                       - TIM_OCFast_Enable
   1208          *                       - TIM_OCFast_Disable
   1209          * Output         : None
   1210          * Return         : None
   1211          *******************************************************************************/
   1212          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1213          {
   1214            u32 tmpccmr2 = 0;
   1215          
   1216            /* Check the parameters */
   1217            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1218          
   1219            tmpccmr2 = TIMx->CCMR2;
   1220          
   1221            /* Reset the OCFE Bit */
   1222            tmpccmr2 &= CCMR_OC24FE_Mask;
   1223          
   1224            /* Enable or Disable the Output Compare Fast Bit */
   1225            tmpccmr2 |= (u16)(TIM_OCFast << 8);
   1226          
   1227            TIMx->CCMR2 = (u16)tmpccmr2;
   1228          }
   1229          
   1230          /*******************************************************************************
   1231          * Function Name  : TIM_UpdateDisableConfig
   1232          * Description    : Enables or Disables the TIMx Update event.
   1233          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1234          *                  - Newstate: new state of the TIMx peripheral Preload register
   1235          *                    This parameter can be: ENABLE or DISABLE.
   1236          * Output         : None
   1237          * Return         : None
   1238          *******************************************************************************/
   1239          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState Newstate)
   1240          {
   1241            u32 tmpcr1 = 0;
   1242          
   1243            /* Check the parameters */
   1244            assert(IS_FUNCTIONAL_STATE(Newstate));
   1245          
   1246            tmpcr1 = TIMx->CR1;
   1247          
   1248            if (Newstate != DISABLE)
   1249            {
   1250              /* Set the Update Disable Bit */
   1251              tmpcr1 |= CR1_UDIS_Set;
   1252            }
   1253            else
   1254            {
   1255              /* Reset the Update Disable Bit */
   1256              tmpcr1 &= CR1_UDIS_Reset;
   1257            }
   1258          
   1259            TIMx->CR1 = (u16)tmpcr1;
   1260          }
   1261          
   1262          /*******************************************************************************
   1263          * Function Name  : TIM_EncoderInterfaceConfig
   1264          * Description    : Configures the TIMx Encoder Interface.
   1265          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1266          *                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1267          *                    This parameter can be one of the following values:
   1268          *                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
   1269          *                         depending on TI2FP2 level.
   1270          *                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
   1271          *                         depending on TI1FP1 level.
   1272          *                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
   1273          *                         TI2FP2 edges depending on the level of the other input.
   1274          *                  - TIM_IC1Polarity: specifies the IC1 Polarity
   1275          *                    This parmeter can be one of the following values:
   1276          *                        - TIM_ICPolarity_Falling
   1277          *                        - TIM_ICPolarity_Rising
   1278          *                  - TIM_IC2Polarity: specifies the IC2 Polarity
   1279          *                    This parmeter can be one of the following values:
   1280          *                       - TIM_ICPolarity_Falling
   1281          *                       - TIM_ICPolarity_Rising
   1282          * Output         : None
   1283          * Return         : None
   1284          *******************************************************************************/
   1285          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
   1286                                          u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
   1287          {
   1288            u32 tmpsmcr = 0;
   1289            u32 tmpccmr1 = 0;
   1290            u32 tmpccer = 0;
   1291              
   1292            /* Check the parameters */
   1293            assert(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1294            assert(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1295            assert(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1296          
   1297            tmpsmcr = TIMx->SMCR;
   1298            tmpccmr1 = TIMx->CCMR1;
   1299            tmpccer = TIMx->CCER;
   1300          
   1301            /* Set the encoder Mode */
   1302            tmpsmcr &= SMCR_SMS_Mask;
   1303            tmpsmcr |= TIM_EncoderMode;
   1304          
   1305            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1306            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
   1307            tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
   1308          
   1309            /* Set the TI1 and the TI2 Polarities */
   1310            tmpccer &= CCER_CC1P_Mask & CCER_CC2P_Mask;
   1311            tmpccer |= (TIM_IC1Polarity | (u16)((u16)TIM_IC2Polarity << 4));
   1312          
   1313            TIMx->SMCR = (u16)tmpsmcr;
   1314          
   1315            TIMx->CCMR1 = (u16)tmpccmr1;
   1316          
   1317            TIMx->CCER = (u16)tmpccer;
   1318          }
   1319          
   1320          /*******************************************************************************
   1321          * Function Name  : TIM_GenerateEvent
   1322          * Description    : Configures the TIMx event to be generate by software.
   1323          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1324          *                  - TIM_EventSource: specifies the event source.
   1325          *                    This parameter can be one or more of the following values:
   1326          *                       - TIM_EventSource_Update: Timer update Event source
   1327          *                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   1328          *                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   1329          *                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   1330          *                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   1331          *                       - TIM_EventSource_Trigger: Timer Trigger Event source
   1332          * Output         : None
   1333          * Return         : None
   1334          *******************************************************************************/
   1335          void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
   1336          {
   1337            /* Check the parameters */
   1338            assert(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   1339          
   1340            /* Set the event sources */
   1341            TIMx->EGR |= TIM_EventSource;
   1342          }
   1343          
   1344          /*******************************************************************************
   1345          * Function Name  : TIM_OC1PolarityConfig
   1346          * Description    : Configures the TIMx channel 1 polarity.
   1347          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1348          *                  - TIM_OCPolarity: specifies the OC1 Polarity
   1349          *                    This parmeter can be one of the following values:
   1350          *                       - TIM_OCPolarity_High: Output Compare active high
   1351          *                       - TIM_OCPolarity_Low: Output Compare active low
   1352          * Output         : None
   1353          * Return         : None
   1354          *******************************************************************************/
   1355          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1356          {
   1357            u32 tmpccer = 0;
   1358          
   1359            /* Check the parameters */
   1360            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1361          
   1362            tmpccer = TIMx->CCER;
   1363          
   1364            /* Set or Reset the CC1P Bit */
   1365            tmpccer &= CCER_CC1P_Mask;
   1366            tmpccer |= TIM_OCPolarity;
   1367          
   1368            TIMx->CCER = (u16)tmpccer;
   1369          }
   1370          
   1371          /*******************************************************************************
   1372          * Function Name  : TIM_OC2PolarityConfig
   1373          * Description    : Configures the TIMx channel 2 polarity.
   1374          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1375          *                  - TIM_OCPolarity: specifies the OC2 Polarity
   1376          *                    This parmeter can be one of the following values:
   1377          *                       - TIM_OCPolarity_High: Output Compare active high
   1378          *                       - TIM_OCPolarity_Low: Output Compare active low
   1379          * Output         : None
   1380          * Return         : None
   1381          *******************************************************************************/
   1382          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1383          {
   1384            u32 tmpccer = 0;
   1385          
   1386            /* Check the parameters */
   1387            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1388          
   1389            tmpccer = TIMx->CCER;
   1390          
   1391            /* Set or Reset the CC2P Bit */
   1392            tmpccer &= CCER_CC2P_Mask;
   1393            tmpccer |= (u16)((u16)TIM_OCPolarity << 4);
   1394          
   1395            TIMx->CCER = (u16)tmpccer;
   1396          }
   1397          
   1398          /*******************************************************************************
   1399          * Function Name  : TIM_OC3PolarityConfig
   1400          * Description    : Configures the TIMx channel 3 polarity.
   1401          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1402          *                  - TIM_OCPolarity: specifies the OC3 Polarity
   1403          *                    This parmeter can be one of the following values:
   1404          *                       - TIM_OCPolarity_High: Output Compare active high
   1405          *                       - TIM_OCPolarity_Low: Output Compare active low
   1406          * Output         : None
   1407          * Return         : None
   1408          *******************************************************************************/
   1409          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1410          {
   1411            u32 tmpccer = 0;
   1412          
   1413            /* Check the parameters */
   1414            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1415          
   1416            tmpccer = TIMx->CCER;
   1417          
   1418            /* Set or Reset the CC3P Bit */
   1419            tmpccer &= CCER_CC3P_Mask;
   1420            tmpccer |= (u16)((u16)TIM_OCPolarity << 8);
   1421          
   1422            TIMx->CCER = (u16)tmpccer;
   1423          }
   1424          
   1425          /*******************************************************************************
   1426          * Function Name  : TIM_OC4PolarityConfig
   1427          * Description    : Configures the TIMx channel 4 polarity.
   1428          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1429          *                  - TIM_OCPolarity: specifies the OC4 Polarity
   1430          *                    This parmeter can be one of the following values:
   1431          *                       - TIM_OCPolarity_High: Output Compare active high
   1432          *                       - TIM_OCPolarity_Low: Output Compare active low
   1433          * Output         : None
   1434          * Return         : None
   1435          *******************************************************************************/
   1436          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1437          {
   1438            u32 tmpccer = 0;
   1439          
   1440            /* Check the parameters */
   1441            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1442          
   1443            tmpccer = TIMx->CCER;
   1444          
   1445            /* Set or Reset the CC4P Bit */
   1446            tmpccer &= CCER_CC4P_Mask;
   1447            tmpccer |= (u16)((u16)TIM_OCPolarity << 12);
   1448          
   1449            TIMx->CCER = (u16)tmpccer;
   1450          }
   1451          
   1452          /*******************************************************************************
   1453          * Function Name  : TIM_UpdateRequestConfig
   1454          * Description    : Configures the TIMx Update Request Interrupt source.
   1455          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1456          *                  - TIM_UpdateSource: specifies the Update source.
   1457          *                    This parameter can be one of the following values:
   1458          *                       - TIM_UpdateSource_Regular
   1459          *                       - TIM_UpdateSource_Global
   1460          * Output         : None
   1461          * Return         : None
   1462          *******************************************************************************/
   1463          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
   1464          {
   1465            u32 tmpcr1 = 0;
   1466          
   1467            /* Check the parameters */
   1468            assert(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   1469          
   1470            tmpcr1 = TIMx->CR1;
   1471          
   1472            if (TIM_UpdateSource == TIM_UpdateSource_Regular)
   1473            {
   1474              /* Set the URS Bit */
   1475              tmpcr1 |= CR1_URS_Set;
   1476            }
   1477            else
   1478            {
   1479              /* Reset the URS Bit */
   1480              tmpcr1 &= CR1_URS_Reset;
   1481            }
   1482            TIMx->CR1 = (u16)tmpcr1;
   1483          }
   1484          
   1485          /*******************************************************************************
   1486          * Function Name  : TIM_SelectHallSensor
   1487          * Description    : Enables or disables the TIMxs Hall sensor interface.
   1488          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1489          *                  - Newstate: new state of the TIMx Hall sensor interface.
   1490          *                    This parameter can be: ENABLE or DISABLE.
   1491          * Output         : None
   1492          * Return         : None
   1493          *******************************************************************************/
   1494          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState Newstate)
   1495          {
   1496            /* Check the parameters */
   1497            assert(IS_FUNCTIONAL_STATE(Newstate));
   1498          
   1499            if (Newstate != DISABLE)
   1500            {
   1501              /* Set the TI1S Bit */
   1502              TIMx->CR2 |= CR2_TI1S_Set;
   1503            }
   1504            else
   1505            {
   1506              /* Reset the TI1S Bit */
   1507              TIMx->CR2 &= CR2_TI1S_Reset;
   1508            }
   1509          }
   1510          
   1511          /*******************************************************************************
   1512          * Function Name  : TIM_SelectOnePulseMode
   1513          * Description    : Selects the TIMxs One Pulse Mode.
   1514          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1515          *                  - TIM_OPMode: specifies the OPM Mode to be used.
   1516          *                    This parameter can be one of the following values:
   1517          *                       - TIM_OPMode_Single
   1518          *                       - TIM_OPMode_Repetitive
   1519          * Output         : None
   1520          * Return         : None
   1521          *******************************************************************************/
   1522          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
   1523          {
   1524            u32 tmpcr1 = 0;
   1525          
   1526            /* Check the parameters */
   1527            assert(IS_TIM_OPM_MODE(TIM_OPMode));
   1528          
   1529            tmpcr1 = TIMx->CR1;
   1530          
   1531            /* Reset the OPM Bit */
   1532            tmpcr1 &= CR1_OPM_Mask;
   1533          
   1534            /* Configure the OPM Mode */
   1535            tmpcr1 |= TIM_OPMode;
   1536          
   1537            TIMx->CR1 = (u16)tmpcr1;
   1538          }
   1539          
   1540          /*******************************************************************************
   1541          * Function Name  : TIM_SelectOutputTrigger
   1542          * Description    : Selects the TIMx Trigger Output Mode.
   1543          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1544          *                  - TIM_TRGOSource: specifies the Trigger Output source.
   1545          *                    This paramter can be one of the following values:
   1546          *                       - TIM_TRGOSource_Reset
   1547          *                       - TIM_TRGOSource_Enable
   1548          *                       - TIM_TRGOSource_Update
   1549          *                       - TIM_TRGOSource_OC1
   1550          *                       - TIM_TRGOSource_OC1Ref
   1551          *                       - TIM_TRGOSource_OC2Ref
   1552          *                       - TIM_TRGOSource_OC3Ref
   1553          *                       - TIM_TRGOSource_OC4Ref
   1554          * Output         : None
   1555          * Return         : None
   1556          *******************************************************************************/
   1557          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
   1558          {
   1559            u32 tmpcr2 = 0;
   1560          
   1561            /* Check the parameters */
   1562            assert(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   1563          
   1564            tmpcr2 = TIMx->CR2;
   1565            /* Reset the MMS Bits */
   1566            tmpcr2 &= CR2_MMS_Mask;
   1567          
   1568            /* Select the TRGO source */
   1569            tmpcr2 |=  TIM_TRGOSource;
   1570          
   1571            TIMx->CR2 = (u16)tmpcr2;
   1572          }
   1573          
   1574          /*******************************************************************************
   1575          * Function Name  : TIM_SelectSlaveMode
   1576          * Description    : Selects the TIMx Slave Mode.
   1577          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1578          *                  - TIM_SlaveMode: specifies the Timer Slave Mode.
   1579          *                    This paramter can be one of the following values:
   1580          *                       - TIM_SlaveMode_Reset
   1581          *                       - TIM_SlaveMode_Gated
   1582          *                       - TIM_SlaveMode_Trigger
   1583          *                       - TIM_SlaveMode_External1
   1584          * Output         : None
   1585          * Return         : None
   1586          *******************************************************************************/
   1587          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
   1588          {
   1589            u32 tmpsmcr = 0;
   1590          
   1591            /* Check the parameters */
   1592            assert(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   1593          
   1594            tmpsmcr = TIMx->SMCR;
   1595          
   1596            /* Reset the SMS Bits */
   1597            tmpsmcr &= SMCR_SMS_Mask;
   1598          
   1599            /* Select the Slave Mode */
   1600            tmpsmcr |= TIM_SlaveMode;
   1601          
   1602            TIMx->SMCR = (u16)tmpsmcr;
   1603          }
   1604          
   1605          /*******************************************************************************
   1606          * Function Name  : TIM_SelectMasterSlaveMode
   1607          * Description    : Sets or Resets the TIMx Master/Slave Mode.
   1608          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1609          *                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   1610          *                    This paramter can be one of the following values:
   1611          *                       - TIM_MasterSlaveMode_Enable: synchronization between the
   1612          *                         current timer and its slaves (through TRGO).
   1613          *                       - TIM_MasterSlaveMode_Disable: No action
   1614          * Output         : None
   1615          * Return         : None
   1616          *******************************************************************************/
   1617          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
   1618          {
   1619            u32 tmpsmcr = 0;
   1620          
   1621            /* Check the parameters */
   1622            assert(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   1623          
   1624            tmpsmcr = TIMx->SMCR;
   1625          
   1626            /* Set or Reset the MSM Bit */
   1627            tmpsmcr &= SMCR_MSM_Mask;
   1628            tmpsmcr |= TIM_MasterSlaveMode;
   1629          
   1630            TIMx->SMCR = (u16)tmpsmcr;
   1631          }
   1632          
   1633          /*******************************************************************************
   1634          * Function Name  : TIM_SetAutoreload
   1635          * Description    : Sets the TIMx Autoreload Register value
   1636          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1637          *                  - Autoreload: specifies the Autoreload register new value.
   1638          * Output         : None
   1639          * Return         : None
   1640          *******************************************************************************/
   1641          void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
   1642          {
   1643            /* Set the Autoreload Register value */
   1644            TIMx->ARR = Autoreload;
   1645          }
   1646          
   1647          /*******************************************************************************
   1648          * Function Name  : TIM_SetCompare1
   1649          * Description    : Sets the TIMx Capture Compare1 Register value
   1650          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1651          *                  - Compare1: specifies the Capture Compare1 register new value.
   1652          * Output         : None
   1653          * Return         : None
   1654          *******************************************************************************/
   1655          void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
   1656          {
   1657            /* Set the Capture Compare1 Register value */
   1658            TIMx->CCR1 = Compare1;
   1659          }
   1660          
   1661          /*******************************************************************************
   1662          * Function Name  : TIM_SetCompare2
   1663          * Description    : Sets the TIMx Capture Compare2 Register value
   1664          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1665          *                  - Compare2: specifies the Capture Compare2 register new value.
   1666          * Output         : None
   1667          * Return         : None
   1668          *******************************************************************************/
   1669          void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
   1670          {
   1671            /* Set the Capture Compare2 Register value */
   1672            TIMx->CCR2 = Compare2;
   1673          }
   1674          
   1675          /*******************************************************************************
   1676          * Function Name  : TIM_SetCompare3
   1677          * Description    : Sets the TIMx Capture Compare3 Register value
   1678          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1679          *                  - Compare3: specifies the Capture Compare3 register new value.
   1680          * Output         : None
   1681          * Return         : None
   1682          *******************************************************************************/
   1683          void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
   1684          {
   1685            /* Set the Capture Compare3 Register value */
   1686            TIMx->CCR3 = Compare3;
   1687          }
   1688          
   1689          /*******************************************************************************
   1690          * Function Name  : TIM_SetCompare4
   1691          * Description    : Sets the TIMx Capture Compare4 Register value
   1692          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1693          *                  - Compare4: specifies the Capture Compare4 register new value.
   1694          * Output         : None
   1695          * Return         : None
   1696          *******************************************************************************/
   1697          void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
   1698          {
   1699            /* Set the Capture Compare4 Register value */
   1700            TIMx->CCR4 = Compare4;
   1701          }
   1702          
   1703          /*******************************************************************************
   1704          * Function Name  : TIM_SetIC1Prescaler
   1705          * Description    : Sets the TIMx Input Capture 1 prescaler.
   1706          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1707          *                  - TIM_IC1Prescaler: specifies the Input Capture1 prescaler
   1708          *                    new value.
   1709          *                    This parameter can be one of the following values:
   1710          *                       - TIM_ICPSC_DIV1: no prescaler
   1711          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1712          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1713          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1714          * Output         : None
   1715          * Return         : None
   1716          *******************************************************************************/
   1717          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC1Prescaler)
   1718          {
   1719            u32 tmpccmr1 = 0;
   1720          
   1721            /* Check the parameters */
   1722            assert(IS_TIM_IC_PRESCALER(TIM_IC1Prescaler));
   1723          
   1724            tmpccmr1 = TIMx->CCMR1;
   1725          
   1726            /* Reset the IC1PSC Bits */
   1727            tmpccmr1 &= CCMR_IC13PSC_Mask;
   1728          
   1729            /* Set the IC1PSC value */
   1730            tmpccmr1 |= TIM_IC1Prescaler;
   1731          
   1732            TIMx->CCMR1 = (u16)tmpccmr1;
   1733          }
   1734          
   1735          /*******************************************************************************
   1736          * Function Name  : TIM_SetIC2Prescaler
   1737          * Description    : Sets the TIMx Input Capture 2 prescaler.
   1738          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1739          *                  - TIM_IC2Prescaler: specifies the Input Capture2 prescaler
   1740          *                    new value.
   1741          *                    This parameter can be one of the following values:
   1742          *                       - TIM_ICPSC_DIV1: no prescaler
   1743          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1744          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1745          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1746          * Output         : None
   1747          * Return         : None
   1748          *******************************************************************************/
   1749          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC2Prescaler)
   1750          {
   1751            u32 tmpccmr1 = 0;
   1752          
   1753            /* Check the parameters */
   1754            assert(IS_TIM_IC_PRESCALER(TIM_IC2Prescaler));
   1755          
   1756            tmpccmr1 = TIMx->CCMR1;
   1757          
   1758            /* Reset the IC2PSC Bits */
   1759            tmpccmr1 &= CCMR_IC24PSC_Mask;
   1760          
   1761            /* Set the IC2PSC value */
   1762            tmpccmr1 |= (u16)((u16)TIM_IC2Prescaler << 8);
   1763          
   1764            TIMx->CCMR1 = (u16)tmpccmr1;
   1765          }
   1766          
   1767          /*******************************************************************************
   1768          * Function Name  : TIM_SetIC3Prescaler
   1769          * Description    : Sets the TIMx Input Capture 3 prescaler.
   1770          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1771          *                  - TIM_IC3Prescaler: specifies the Input Capture3 prescaler
   1772          *                    new value.
   1773          *                    This parameter can be one of the following values:
   1774          *                       - TIM_ICPSC_DIV1: no prescaler
   1775          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1776          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1777          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1778          * Output         : None
   1779          * Return         : None
   1780          *******************************************************************************/
   1781          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC3Prescaler)
   1782          {
   1783            u32 tmpccmr2 = 0;
   1784          
   1785            /* Check the parameters */
   1786            assert(IS_TIM_IC_PRESCALER(TIM_IC3Prescaler));
   1787          
   1788            tmpccmr2 = TIMx->CCMR2;
   1789          
   1790            /* Reset the IC3PSC Bits */
   1791            tmpccmr2 &= CCMR_IC13PSC_Mask;
   1792          
   1793            /* Set the IC3PSC value */
   1794            tmpccmr2 |= TIM_IC3Prescaler;
   1795          
   1796            TIMx->CCMR2 = (u16)tmpccmr2;
   1797          }
   1798          
   1799          /*******************************************************************************
   1800          * Function Name  : TIM_SetIC4Prescaler
   1801          * Description    : Sets the TIMx Input Capture 4 prescaler.
   1802          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1803          *                  - TIM_IC4Prescaler: specifies the Input Capture4 prescaler
   1804          *                    new value.
   1805          *                    This parameter can be one of the following values:
   1806          *                      - TIM_ICPSC_DIV1: no prescaler
   1807          *                      - TIM_ICPSC_DIV2: capture is done once every 2 events
   1808          *                      - TIM_ICPSC_DIV4: capture is done once every 4 events
   1809          *                      - TIM_ICPSC_DIV8: capture is done once every 8 events
   1810          * Output         : None
   1811          * Return         : None
   1812          *******************************************************************************/
   1813          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC4Prescaler)
   1814          {
   1815            u32 tmpccmr2 = 0;
   1816             
   1817            /* Check the parameters */
   1818            assert(IS_TIM_IC_PRESCALER(TIM_IC4Prescaler));
   1819          
   1820            tmpccmr2 = TIMx->CCMR2;
   1821          
   1822            /* Reset the IC4PSC Bits */
   1823            tmpccmr2 &= CCMR_IC24PSC_Mask;
   1824          
   1825            /* Set the IC4PSC value */
   1826            tmpccmr2 |= (u16)((u16)TIM_IC4Prescaler << 8);
   1827          
   1828            TIMx->CCMR2 = (u16)tmpccmr2;
   1829          }
   1830          
   1831          /*******************************************************************************
   1832          * Function Name  : TIM_SetClockDivision
   1833          * Description    : Sets the TIMx Clock Division value.
   1834          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1835          *                  - TIM_CKD: specifies the clock division value.
   1836          *                    This parameter can be one of the following value:
   1837          *                       - TIM_CKD_DIV1: TDTS = Tck_tim
   1838          *                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
   1839          *                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
   1840          * Output         : None
   1841          * Return         : None
   1842          *******************************************************************************/
   1843          void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
   1844          {
   1845            u32 tmpcr1 = 0;
   1846          
   1847            /* Check the parameters */
   1848            assert(IS_TIM_CKD_DIV(TIM_CKD));
   1849          
   1850            tmpcr1 = TIMx->CR1;
   1851          
   1852            /* Reset the CKD Bits */
   1853            tmpcr1 &= CR1_CKD_Mask;
   1854          
   1855            /* Set the CKD value */
   1856            tmpcr1 |= TIM_CKD;
   1857          
   1858            TIMx->CR1 = (u16)tmpcr1;
   1859          }
   1860          
   1861          /*******************************************************************************
   1862          * Function Name  : TIM_GetCapture1
   1863          * Description    : Gets the TIMx Input Capture 1 value.
   1864          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1865          * Output         : None
   1866          * Return         : Capture Compare 1 Register value.
   1867          *******************************************************************************/
   1868          u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
   1869          {
   1870            /* Get the Capture 1 Register value */
   1871            return TIMx->CCR1;
   1872          }
   1873          
   1874          /*******************************************************************************
   1875          * Function Name  : TIM_GetCapture2
   1876          * Description    : Gets the TIMx Input Capture 2 value.
   1877          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1878          * Output         : None
   1879          * Return         : Capture Compare 2 Register value.
   1880          *******************************************************************************/
   1881          u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
   1882          {
   1883            /* Get the Capture 2 Register value */
   1884            return TIMx->CCR2;
   1885          }
   1886          
   1887          /*******************************************************************************
   1888          * Function Name  : TIM_GetCapture3
   1889          * Description    : Gets the TIMx Input Capture 3 value.
   1890          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1891          * Output         : None
   1892          * Return         : Capture Compare 3 Register value.
   1893          *******************************************************************************/
   1894          u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
   1895          {
   1896            /* Get the Capture 3 Register value */
   1897            return TIMx->CCR3;
   1898          }
   1899          
   1900          /*******************************************************************************
   1901          * Function Name  : TIM_GetCapture4
   1902          * Description    : Gets the TIMx Input Capture 4 value.
   1903          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1904          * Output         : None
   1905          * Return         : Capture Compare 4 Register value.
   1906          *******************************************************************************/
   1907          u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
   1908          {
   1909            /* Get the Capture 4 Register value */
   1910            return TIMx->CCR4;
   1911          }
   1912          
   1913          /*******************************************************************************
   1914          * Function Name  : TIM_GetCounter
   1915          * Description    : Gets the TIMx Counter value.
   1916          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1917          * Output         : None
   1918          * Return         : Counter Register value.
   1919          *******************************************************************************/
   1920          u16 TIM_GetCounter(TIM_TypeDef* TIMx)
   1921          {
   1922            /* Get the Counter Register value */
   1923            return TIMx->CNT;
   1924          }
   1925          
   1926          /*******************************************************************************
   1927          * Function Name  : TIM_GetPrescaler
   1928          * Description    : Gets the TIMx Prescaler value.
   1929          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1930          * Output         : None
   1931          * Return         : Prescaler Register value.
   1932          *******************************************************************************/
   1933          u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
   1934          {
   1935            /* Get the Prescaler Register value */
   1936            return TIMx->PSC;
   1937          }
   1938          
   1939          /*******************************************************************************
   1940          * Function Name  : TIM_GetFlagStatus
   1941          * Description    : Checks whether the specified TIMx flag is set or not.
   1942          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1943          *                  - TIM_FLAG: specifies the flag to check.
   1944          *                    This parameter can be one of the following values:
   1945          *                       - TIM_FLAG_Update: Timer update Flag
   1946          *                       - TIM_FLAG_CC1: Timer Capture Compare 1 Flag
   1947          *                       - TIM_FLAG_CC2: Timer Capture Compare 2 Flag
   1948          *                       - TIM_FLAG_CC3: Timer Capture Compare 3 Flag
   1949          *                       - TIM_FLAG_CC4: Timer Capture Compare 4 Flag
   1950          *                       - TIM_FLAG_Trigger: Timer Trigger Flag
   1951          *                       - TIM_FLAG_CC1OF: Timer Capture Compare 1 overcapture Flag
   1952          *                       - TIM_FLAG_CC2OF: Timer Capture Compare 2 overcapture Flag
   1953          *                       - TIM_FLAG_CC3OF: Timer Capture Compare 3 overcapture Flag
   1954          *                       - TIM_FLAG_CC4OF: Timer Capture Compare 4 overcapture Flag
   1955          * Output         : None
   1956          * Return         : The new state of TIM_FLAG (SET or RESET).
   1957          *******************************************************************************/
   1958          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   1959          {
   1960            FlagStatus bitstatus = RESET;
   1961          
   1962            /* Check the parameters */
   1963            assert(IS_TIM_GET_FLAG(TIM_FLAG));
   1964          
   1965            if ((TIMx->SR & TIM_FLAG) != (u16)RESET )
   1966            {
   1967              bitstatus = SET;
   1968            }
   1969            else
   1970            {
   1971              bitstatus = RESET;
   1972            }
   1973            return bitstatus;
   1974          }
   1975          
   1976          /*******************************************************************************
   1977          * Function Name  : TIM_ClearFlag
   1978          * Description    : Clears the TIMx's pending flags.
   1979          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1980          *                  - TIM_FLAG: specifies the flag bit to clear.
   1981          *                    This parameter can be any combination of the following values:
   1982          *                       - TIM_FLAG_Update: Timer update Flag
   1983          *                       - TIM_FLAG_CC1: Timer Capture Compare 1 Flag
   1984          *                       - TIM_FLAG_CC2: Timer Capture Compare 2 Flag
   1985          *                       - TIM_FLAG_CC3: Timer Capture Compare 3 Flag
   1986          *                       - TIM_FLAG_CC4: Timer Capture Compare 4 Flag
   1987          *                       - TIM_FLAG_Trigger: Timer Trigger Flag
   1988          *                       - TIM_FLAG_CC1OF: Timer Capture Compare 1 overcapture Flag
   1989          *                       - TIM_FLAG_CC2OF: Timer Capture Compare 2 overcapture Flag
   1990          *                       - TIM_FLAG_CC3OF: Timer Capture Compare 3 overcapture Flag
   1991          *                       - TIM_FLAG_CC4OF: Timer Capture Compare 4 overcapture Flag
   1992          * Output         : None
   1993          * Return         : None
   1994          *******************************************************************************/
   1995          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   1996          {
   1997            /* Check the parameters */
   1998            assert(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   1999          
   2000            /* Clear the flags */
   2001            TIMx->SR &= (u16)~TIM_FLAG;
   2002          }
   2003          
   2004          /*******************************************************************************
   2005          * Function Name  : TIM_GetITStatus
   2006          * Description    : Checks whether the TIMx interrupt has occurred or not.
   2007          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2008          *                  - TIM_IT: specifies the TIM interrupt source to check.
   2009          *                    This parameter can be one of the following values:
   2010          *                         - TIM_IT_Update: Timer update Interrupt source
   2011          *                         - TIM_IT_CC1: Timer Capture Compare 1 Interrupt source
   2012          *                         - TIM_IT_CC2: Timer Capture Compare 2 Interrupt source
   2013          *                         - TIM_IT_CC3: Timer Capture Compare 3 Interrupt source
   2014          *                         - TIM_IT_CC4: Timer Capture Compare 4 Interrupt source
   2015          *                         - TIM_IT_Trigger: Timer Trigger Interrupt source
   2016          * Output         : None
   2017          * Return         : The new state of the TIM_IT(SET or RESET).
   2018          *******************************************************************************/
   2019          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   2020          {
   2021            ITStatus bitstatus = RESET;
   2022            
   2023            u16 itstatus = 0x0, itenable = 0x0;
   2024          
   2025            /* Check the parameters */
   2026            assert(IS_TIM_GET_IT(TIM_IT));
   2027            
   2028            itstatus = TIMx->SR & TIM_IT;
   2029            
   2030            itenable = TIMx->DIER & TIM_IT;
   2031          
   2032            if ((itstatus != (u16)RESET)  && (itenable != (u16)RESET))
   2033            {
   2034              bitstatus = SET;
   2035            }
   2036            else
   2037            {
   2038              bitstatus = RESET;
   2039            }
   2040            return bitstatus;
   2041          }
   2042          
   2043          /*******************************************************************************
   2044          * Function Name  : TIM_ClearITPendingBit
   2045          * Description    : Clears the TIMx's interrupt pending bits.
   2046          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2047          *                  - TIM_IT: specifies the pending bit to clear.
   2048          *                    This parameter can be any combination of the following values:
   2049          *                       - TIM_IT_Update: Timer update Interrupt source
   2050          *                       - TIM_IT_CC1: Timer Capture Compare 1 Interrupt source
   2051          *                       - TIM_IT_CC2: Timer Capture Compare 2 Interrupt source
   2052          *                       - TIM_IT_CC3: Timer Capture Compare 3 Interrupt source
   2053          *                       - TIM_IT_CC4: Timer Capture Compare 4 Interrupt source
   2054          *                       - TIM_IT_Trigger: Timer Trigger Interrupt source
   2055          * Output         : None
   2056          * Return         : None
   2057          *******************************************************************************/
   2058          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   2059          {
   2060            /* Check the parameters */
   2061            assert(IS_TIM_IT(TIM_IT));
   2062            
   2063            /* Clear the IT pending Bit */
   2064            TIMx->SR &= (u16)~TIM_IT;
   2065          }
   2066          
   2067          /*******************************************************************************
   2068          * Function Name  : PWMInput_Config
   2069          * Description    : Configures the TIM peripheral according to the specified
   2070          *                  parameters in the TIM_ICInitStruct to measure an external PWM
   2071          *                  signal.
   2072          * Input          : - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   2073          *                    that contains the configuration information for the specified
   2074          *                    TIM peripheral.
   2075          * Output         : None
   2076          * Return         : None
   2077          *******************************************************************************/
   2078          static void PWMI_Config(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   2079          {
   2080            u8 ICPolarity = TIM_ICPolarity_Rising;
   2081            u8 ICSelection = TIM_ICSelection_DirectTI;
   2082          
   2083            /* Select the Opposite Input Polarity */
   2084            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   2085            {
   2086              ICPolarity = TIM_ICPolarity_Falling;
   2087            }
   2088            else
   2089            {
   2090              ICPolarity = TIM_ICPolarity_Rising;
   2091            }
   2092          
   2093            /* Select the Opposite Input */
   2094            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   2095            {
   2096              ICSelection = TIM_ICSelection_IndirectTI;
   2097            }
   2098            else
   2099            {
   2100              ICSelection = TIM_ICSelection_DirectTI;
   2101            }
   2102          
   2103            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   2104            {
   2105              /* TI1 Configuration */
   2106              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2107                         TIM_ICInitStruct->TIM_ICFilter);
   2108          
   2109              /* Set the Input Capture Prescaler value */
   2110              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2111          
   2112              /* TI2 Configuration */
   2113              TI2_Config(TIMx, ICPolarity, ICSelection, TIM_ICInitStruct->TIM_ICFilter);
   2114          
   2115              /* Set the Input Capture Prescaler value */
   2116              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2117            }
   2118            else
   2119            {	 
   2120              /* TI1 Configuration */
   2121              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2122                         TIM_ICInitStruct->TIM_ICFilter);
   2123          
   2124              /* Set the Input Capture Prescaler value */
   2125              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2126          
   2127              /* TI2 Configuration */
   2128              TI1_Config(TIMx, ICPolarity, ICSelection, TIM_ICInitStruct->TIM_ICFilter);
   2129          
   2130              /* Set the Input Capture Prescaler value */
   2131              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2132            }
   2133          }
   2134          
   2135          /*******************************************************************************
   2136          * Function Name  : TI1_Config
   2137          * Description    : Configure the TI1 as Input.
   2138          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2139          *                  - TIM_ICPolarity : The Input Polarity.
   2140          *                    This parameter can be one of the following values:
   2141          *                       - TIM_ICPolarity_Rising
   2142          *                       - TIM_ICPolarity_Falling
   2143          *                  - TIM_ICSelection: specifies the input to be used.
   2144          *                    This parameter can be one of the following values:
   2145          *                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
   2146          *                         be connected to IC1.
   2147          *                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
   2148          *                         be connected to IC2.
   2149          *                       - TIM_ICSelection_TRGI: TIM Input 1 is selected to be
   2150          *                         connected to TRGI.
   2151          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2152          *                    This parameter must be a value between 0x00 and 0x0F.
   2153          * Output         : None
   2154          * Return         : None
   2155          *******************************************************************************/
   2156          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2157                                 u8 TIM_ICFilter)
   2158          {
   2159            u32 tmpccmr1 = 0, tmpccer = 0;
   2160          
   2161            tmpccmr1 = TIMx->CCMR1;
   2162            tmpccer = TIMx->CCER;
   2163          
   2164            /* Disable the Channel 1: Reset the CCE Bit */
   2165            TIMx->CCER &= CCRE_CC1E_Reset;
   2166          
   2167            /* Select the Input and set the filter */
   2168            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   2169            tmpccmr1 |= TIM_ICSelection | (u16)((u16)TIM_ICFilter << 4);
   2170          
   2171            /* Select the Polarity  and set the CCE Bit */
   2172            tmpccer &= CCER_CC1P_Mask & CCRE_CC1E_Mask;
   2173            tmpccer |= TIM_ICPolarity | CCRE_CC1E_Set;
   2174          
   2175            TIMx->CCMR1 = 0x0000;
   2176            TIMx->CCMR1 = (u16)tmpccmr1;
   2177            TIMx->CCER = (u16)tmpccer;
   2178          }
   2179          
   2180          /*******************************************************************************
   2181          * Function Name  : TI2_Config
   2182          * Description    : Configure the TI2 as Input.
   2183          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2184          *                  - TIM_ICPolarity : The Input Polarity.
   2185          *                    This parameter can be one of the following values:
   2186          *                       - TIM_ICPolarity_Rising
   2187          *                       - TIM_ICPolarity_Falling
   2188          *                  - TIM_ICSelection: specifies the input to be used.
   2189          *                    This parameter can be one of the following values:
   2190          *                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
   2191          *                         be connected to IC2.
   2192          *                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
   2193          *                         be connected to IC1.
   2194          *                       - TIM_ICSelection_TRGI: TIM Input 2 is selected to be
   2195          *                         connected to TRGI.
   2196          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2197          *                    This parameter must be a value between 0x00 and 0x0F.
   2198          * Output         : None
   2199          * Return         : None
   2200          *******************************************************************************/
   2201          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2202                                 u8 TIM_ICFilter)
   2203          {
   2204            u32 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2205          
   2206            tmpccmr1 = TIMx->CCMR1;
   2207            tmpccer = TIMx->CCER;
   2208            tmp = (u16)((u16)TIM_ICPolarity << 4);
   2209          
   2210            /* Disable the Channel 2: Reset the CCE Bit */
   2211            TIMx->CCER &= CCRE_CC2E_Reset;
   2212          
   2213            /* Select the Input and set the filter */
   2214            tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   2215            tmpccmr1 |= (u16)((u16)TIM_ICFilter << 12);
   2216            tmpccmr1 |= (u16)((u16)TIM_ICSelection << 8);
   2217          
   2218            /* Select the Polarity  and set the CCE Bit */
   2219            tmpccer &= CCER_CC2P_Mask & CCRE_CC2E_Mask;
   2220            tmpccer |=  tmp | CCRE_CC2E_Set;
   2221          
   2222            TIMx->CCMR1 = (u16)tmpccmr1 ;
   2223            TIMx->CCER = (u16)tmpccer;
   2224          }
   2225          
   2226          /*******************************************************************************
   2227          * Function Name  : TI3_Config
   2228          * Description    : Configure the TI3 as Input.
   2229          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2230          *                  - TIM_ICPolarity : The Input Polarity.
   2231          *                    This parameter can be one of the following values:
   2232          *                       - TIM_ICPolarity_Rising
   2233          *                       - TIM_ICPolarity_Falling
   2234          *                  - TIM_ICSelection: specifies the input to be used.
   2235          *                    This parameter can be one of the following values:
   2236          *                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
   2237          *                         be connected to IC3.
   2238          *                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
   2239          *                         be connected to IC4.
   2240          *                       - TIM_ICSelection_TRGI: TIM Input 3 is selected to be
   2241          *                         connected to TRGI.
   2242          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2243          *                    This parameter must be a value between 0x00 and 0x0F.
   2244          * Output         : None
   2245          * Return         : None
   2246          *******************************************************************************/
   2247          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2248                                 u8 TIM_ICFilter)
   2249          {
   2250            u32 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2251          
   2252            tmpccmr2 = TIMx->CCMR2;
   2253            tmpccer = TIMx->CCER;
   2254            tmp = (u16)((u16)TIM_ICPolarity << 8);
   2255          
   2256            /* Disable the Channel 3: Reset the CCE Bit */
   2257            TIMx->CCER &= CCRE_CC3E_Reset;
   2258          
   2259            /* Select the Input and set the filter */
   2260            tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   2261            tmpccmr2 |= TIM_ICSelection | (u16)((u16)TIM_ICFilter << 4);
   2262          
   2263            /* Select the Polarity  and set the CCE Bit */
   2264            tmpccer &= CCER_CC1P_Mask & CCRE_CC1E_Mask;
   2265            tmpccer |= tmp | CCRE_CC3E_Set;
   2266          
   2267            TIMx->CCMR2 = (u16)tmpccmr2;
   2268            TIMx->CCER = (u16)tmpccer;
   2269          }
   2270          
   2271          /*******************************************************************************
   2272          * Function Name  : TI4_Config
   2273          * Description    : Configure the TI1 as Input.
   2274          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2275          *                  - TIM_ICPolarity : The Input Polarity.
   2276          *                    This parameter can be one of the following values:
   2277          *                       - TIM_ICPolarity_Rising
   2278          *                       - TIM_ICPolarity_Falling
   2279          *                  - TIM_ICSelection: specifies the input to be used.
   2280          *                    This parameter can be one of the following values:
   2281          *                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
   2282          *                         be connected to IC4.
   2283          *                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
   2284          *                         be connected to IC3.
   2285          *                       - TIM_ICSelection_TRGI: TIM Input 4 is selected to be
   2286          *                         connected to TRGI.
   2287          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2288          *                    This parameter must be a value between 0x00 and 0x0F.
   2289          * Output         : None
   2290          * Return         : None
   2291          *******************************************************************************/
   2292          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2293                                 u8 TIM_ICFilter)
   2294          {
   2295            u32 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2296          
   2297            tmpccmr2 = TIMx->CCMR2;
   2298            tmpccer = TIMx->CCER;
   2299            tmp = (u16)((u16)TIM_ICPolarity << 12);
   2300          
   2301            /* Disable the Channel 4: Reset the CCE Bit */
   2302            TIMx->CCER &= CCRE_CC4E_Reset;
   2303          
   2304            /* Select the Input and set the filter */
   2305            tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   2306            tmpccmr2 |= (u16)((u16)TIM_ICSelection << 8) | (u16)((u16)TIM_ICFilter << 12);
   2307          
   2308            /* Select the Polarity  and set the CCE Bit */
   2309            tmpccer &= CCER_CC4P_Mask & CCRE_CC4E_Mask;
   2310            tmpccer |= tmp | CCRE_CC4E_Set;
   2311          
   2312            TIMx->CCMR2 = (u16)tmpccmr2;
   2313            TIMx->CCER = (u16)tmpccer ;
   2314          }
   2315          
   2316          /*******************************************************************************
   2317          * Function Name  : ETR_Config
   2318          * Description    : Configure the External Trigger
   2319          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2320          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2321          *                    This parameter can be one of the following values:
   2322          *                       - TIM_ExtTRGPSC_OFF
   2323          *                       - TIM_ExtTRGPSC_DIV2
   2324          *                       - TIM_ExtTRGPSC_DIV4
   2325          *                       - TIM_ExtTRGPSC_DIV8
   2326          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   2327          *                    This parameter can be one of the following values:
   2328          *                       - TIM_ExtTRGPolarity_Inverted
   2329          *                       - TIM_ExtTRGPolarity_NonInverted
   2330          *                  - ExtTRGFilter: External Trigger Filter.
   2331          *                    This parameter must be a value between 0x00 and 0x0F.
   2332          * Output         : None
   2333          * Return         : None
   2334          *******************************************************************************/
   2335          static void ETR_Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   2336                                 u8 ExtTRGFilter)
   2337          {
   2338            u32 tmpsmcr = 0;
   2339          
   2340            tmpsmcr = TIMx->SMCR;
   2341          
   2342            /* Set the Prescaler, the Filter value and the Polarity */
   2343            tmpsmcr &= SMCR_ETR_Mask;
   2344            tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)((u16)ExtTRGFilter << 8);
   2345          
   2346            TIMx->SMCR = (u16)tmpsmcr;
   2347          }
   2348          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   ETR_Config
      24   PWMI_Config
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
      16   TI1_Config
      16   TI2_Config
      16   TI3_Config
      16   TI4_Config
      16   TIM_ARRPreloadConfig
        16   -> assert_failed
      16   TIM_ClearFlag
        16   -> assert_failed
      16   TIM_ClearITPendingBit
        16   -> assert_failed
      16   TIM_Cmd
        16   -> assert_failed
      16   TIM_CounterModeConfig
        16   -> assert_failed
      16   TIM_DMACmd
        16   -> assert_failed
      16   TIM_DMAConfig
        16   -> assert_failed
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
      24   TIM_ETRClockMode1Config
        24   -> ETR_Config
        24   -> assert_failed
      24   TIM_ETRClockMode2Config
        24   -> ETR_Config
        24   -> assert_failed
      24   TIM_EncoderInterfaceConfig
        24   -> assert_failed
      16   TIM_ForcedOC1Config
        16   -> assert_failed
      16   TIM_ForcedOC2Config
        16   -> assert_failed
      16   TIM_ForcedOC3Config
        16   -> assert_failed
      16   TIM_ForcedOC4Config
        16   -> assert_failed
      16   TIM_GenerateEvent
        16   -> assert_failed
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
      16   TIM_GetFlagStatus
        16   -> assert_failed
      16   TIM_GetITStatus
        16   -> assert_failed
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> PWMI_Config
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
        16   -> assert_failed
       0   TIM_ICStructInit
      16   TIM_ITConfig
        16   -> assert_failed
      16   TIM_ITRxExternalClockConfig
        16   -> TIM_SelectInputTrigger
        16   -> assert_failed
       0   TIM_InternalClockConfig
      16   TIM_OC1FastConfig
        16   -> assert_failed
      16   TIM_OC1PolarityConfig
        16   -> assert_failed
      16   TIM_OC1PreloadConfig
        16   -> assert_failed
      16   TIM_OC2FastConfig
        16   -> assert_failed
      16   TIM_OC2PolarityConfig
        16   -> assert_failed
      16   TIM_OC2PreloadConfig
        16   -> assert_failed
      16   TIM_OC3FastConfig
        16   -> assert_failed
      16   TIM_OC3PolarityConfig
        16   -> assert_failed
      16   TIM_OC3PreloadConfig
        16   -> assert_failed
      16   TIM_OC4FastConfig
        16   -> assert_failed
      16   TIM_OC4PolarityConfig
        16   -> assert_failed
      16   TIM_OC4PreloadConfig
        16   -> assert_failed
      16   TIM_OCInit
        16   -> assert_failed
       0   TIM_OCStructInit
      16   TIM_PrescalerConfig
        16   -> assert_failed
      16   TIM_SelectCCDMA
        16   -> assert_failed
      16   TIM_SelectHallSensor
        16   -> assert_failed
      16   TIM_SelectInputTrigger
        16   -> assert_failed
      16   TIM_SelectMasterSlaveMode
        16   -> assert_failed
      16   TIM_SelectOnePulseMode
        16   -> assert_failed
      16   TIM_SelectOutputTrigger
        16   -> assert_failed
      16   TIM_SelectSlaveMode
        16   -> assert_failed
       0   TIM_SetAutoreload
      16   TIM_SetClockDivision
        16   -> assert_failed
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
      16   TIM_SetIC1Prescaler
        16   -> assert_failed
      16   TIM_SetIC2Prescaler
        16   -> assert_failed
      16   TIM_SetIC3Prescaler
        16   -> assert_failed
      16   TIM_SetIC4Prescaler
        16   -> assert_failed
      24   TIM_TIxExternalClockConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SelectInputTrigger
        24   -> assert_failed
      16   TIM_TimeBaseInit
        16   -> assert_failed
       0   TIM_TimeBaseStructInit
      16   TIM_UpdateDisableConfig
        16   -> assert_failed
      16   TIM_UpdateRequestConfig
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable38
       4  ??DataTable40
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable50
     164  ?_0
      32  ETR_Config
     140  PWMI_Config
      64  TI1_Config
      66  TI2_Config
      64  TI3_Config
      64  TI4_Config
      56  TIM_ARRPreloadConfig
      38  TIM_ClearFlag
      38  TIM_ClearITPendingBit
      58  TIM_Cmd
      66  TIM_CounterModeConfig
      84  TIM_DMACmd
     300  TIM_DMAConfig
      82  TIM_DeInit
     134  TIM_ETRClockMode1Config
     106  TIM_ETRClockMode2Config
     140  TIM_EncoderInterfaceConfig
      48  TIM_ForcedOC1Config
      50  TIM_ForcedOC2Config
      48  TIM_ForcedOC3Config
      50  TIM_ForcedOC4Config
      38  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       6  TIM_GetCapture4
       4  TIM_GetCounter
     102  TIM_GetFlagStatus
      88  TIM_GetITStatus
       4  TIM_GetPrescaler
     296  TIM_ICInit
      26  TIM_ICStructInit
      80  TIM_ITConfig
      62  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      48  TIM_OC1FastConfig
      46  TIM_OC1PolarityConfig
      48  TIM_OC1PreloadConfig
      48  TIM_OC2FastConfig
      48  TIM_OC2PolarityConfig
      50  TIM_OC2PreloadConfig
      46  TIM_OC3FastConfig
      48  TIM_OC3PolarityConfig
      48  TIM_OC3PreloadConfig
      48  TIM_OC4FastConfig
      48  TIM_OC4PolarityConfig
      50  TIM_OC4PreloadConfig
     332  TIM_OCInit
      18  TIM_OCStructInit
      60  TIM_PrescalerConfig
      54  TIM_SelectCCDMA
      56  TIM_SelectHallSensor
      84  TIM_SelectInputTrigger
      46  TIM_SelectMasterSlaveMode
      46  TIM_SelectOnePulseMode
      80  TIM_SelectOutputTrigger
      58  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      52  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       6  TIM_SetCompare4
      58  TIM_SetIC1Prescaler
      60  TIM_SetIC2Prescaler
      58  TIM_SetIC3Prescaler
      60  TIM_SetIC4Prescaler
     142  TIM_TIxExternalClockConfig
     108  TIM_TimeBaseInit
      18  TIM_TimeBaseStructInit
      54  TIM_UpdateDisableConfig
      54  TIM_UpdateRequestConfig
       8  Tab_OCModeMask
       8  Tab_PolarityMask

 
   180 bytes in section .rodata
 4 582 bytes in section .text
 
 4 582 bytes of CODE  memory
   180 bytes of CONST memory

Errors: none
Warnings: none
